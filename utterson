#! /usr/bin/env python3

import yaml
import curses
import curses.textpad
import os
import subprocess
import shutil
import argparse
import collections
from curses import wrapper


# Globals
config = None
startup_opts = None
utterson_version = '0.01 - Dev'



def window_prep(stdscr, title, options):
  """Prepare the window by clearing it and ading a border."""
  curses.noecho()
  curses.cbreak()
  curses.curs_set(0)
  stdscr.keypad(True)
  stdscr.clear()
  stdscr.border(0)
  window_header(stdscr, title)

  if (options is not None):
    window_menu(stdscr, options)

def window_header(stdscr, title):
  """Adds a header to the window with the title on the left."""
  header =  ' ' + title + (' ' * (curses.COLS - len(title) - 1))
  stdscr.addstr(0,0,header,curses.A_STANDOUT)

def notice_header(stdscr, notice):
  """Adds the first 50 chracters of the notice to the header."""

  # Buffer the string with spaces if needed.
  notice = notice.strip()
  if (len(notice) > 50):
    text = notice[:50]
  else:
    text = (' ' * (50-len(notice)) + notice)

  stdscr.addstr(0,curses.COLS - 50, text, curses.A_STANDOUT)

def window_menu(stdscr, options):
  """
  Displays the menu items at the bottom of the screen.

  Options = (<letter>: <title>)

  Example

  ('Q':'quit', 'P':'publish') => Q - Quit  P - Publish

  """

  opstr = ''
  for key, value in options.items():
    opstr += (key + " - " + value + "   ")
    stdscr.addstr(curses.LINES - 1 , 2, opstr[:(curses.COLS - 3)])

def build_full_screen_menu(stdscr, opts):
  """

  Builds a fulls screen menu based on opts.

  Example:
  opts = collections.OrderedDict()
      opts['I'] = ['Posts', 'Created/Edit/Delete blog posts.']
      opts['G'] = ['Pages', 'Manage static pages']
      opts['C'] = ['Categories', 'Created/Edit/Delete categories posts']
      opts['T'] = ['Tags', 'Created/Edit/Delete tags posts']
      opts['S'] = ['Settings', 'Manage utterson settings']
      opts['Q'] = ['Quit', 'exit utterson']

  """
  # Calculate center.
  largest_total_length = 0
  largest_word_to_desc_offset = 0
  for key, value in opts.items():
    # Determine the word to desc offset.
    if ((len(value[0]) + 1) > largest_word_to_desc_offset):
      largest_word_to_desc_offset = (len(value[0]) + 1)

    # Determine the total offset.
    if (len(key + value[0] + value[1]) > largest_total_length):
      largest_total_length = len(key + value[0] + value[1])

  # Calculate offsets
  line_offset = (curses.LINES - 2 - len(opts) - len(opts) + 1)//2
  cols_offset = (curses.COLS - largest_total_length - 4 - 3)//2

  item_num = 0
  for key, value in opts.items():
    line = key + '    ' + value[0] + (' ' * (largest_word_to_desc_offset - len(value[0]))) + '- ' + value[1]
    stdscr.addstr(line_offset + item_num, cols_offset, line)
    item_num += 2

def home_screen(stdscr):
  """Runs the home screen"""

  redraw = True
  key = 0

  # Run event loop on keys.
  while (key != ord('q') and key != ord('Q')):

    if (redraw):

      # Calculate menu vertical center.
      lines_offset = (curses.LINES - 2 - 11)//2

      # Calculate horizontal offset.
      cols_offset = (curses.COLS - 45)//2

      # Write the main menu.
      window_prep(stdscr, "utterson", None)
      opts = collections.OrderedDict()
      opts['P'] = ['Posts', 'Created/Edit/Delete blog posts.']
      opts['G'] = ['Pages', 'Manage static pages']
      opts['C'] = ['Categories', 'Created/Edit/Delete categories posts']
      opts['T'] = ['Tags', 'Created/Edit/Delete tags posts']
      opts['S'] = ['Settings', 'Manage utterson settings']
      opts['Q'] = ['Quit', 'exit utterson']

      build_full_screen_menu(stdscr, opts)
      """
      stdscr.addstr(lines_offset,cols_offset,    'P    Posts      - Create/Edit/Delete blog posts')
      stdscr.addstr(lines_offset + 2,cols_offset,'G    Pages      - Manage static pages')
      stdscr.addstr(lines_offset + 4,cols_offset,'C    Categories - Manage categories')
      stdscr.addstr(lines_offset + 6,cols_offset,'T    Tags       - Manage tags')
      stdscr.addstr(lines_offset + 8,cols_offset,'S    Settings   - Manage utterson settings')
      stdscr.addstr(lines_offset + 10,cols_offset,'Q    Quit      - Leave utterson')
      stdscr.refresh()
      redraw = False"""

    key = stdscr.getch()

    if (key == ord('p') or key == ord('P')):
      posts_main_screen(stdscr)

      # Prep the window.
      window_prep(stdscr, "utterson: Home", None)
      redraw = True

def published_post_screen(stdscr):
  """Starts the published post screen."""

  window_prep(stdscr, "utterson:published posts", None)
  stdscr.refresh()

  posts = []
  for f in os.listdir(config['site']['jekyll_root'] + "_posts"):
    if os.path.isfile(config['site']['jekyll_root'] + "_posts/" + f):
      posts.append(f)
  posts.sort(reverse=True)
  il = ItemsListWindow(posts)
  il.set_window_size({'left_type': 'relative', 'left_value': 2,
                       'right_type': 'relative', 'right_value': 50,
                       'bottom_type': 'relative', 'bottom_value': 2,
                       'top_type' : 'relative', 'top_value': 2,
                       'height': 10,
                       'width': 15})
  il.build_item_list()
  il.refresh_window()
  

  key = 0
  while (key != ord('q')):

    key = stdscr.getch()

    if (key == curses.KEY_DOWN):
      il.select_down()
    elif (key == curses.KEY_UP):
      il.select_up()

def draft_post_screen(stdscr):
  """Starts the draft post screen."""

  redraw = True
  rebuild_file_list = True
  notice_txt = None
  

  key = 0
  while (key != ord('q') and key != ord('Q')):

    if (rebuild_file_list):
      posts = []
      for f in os.listdir(config['site']['jekyll_root'] + "_posts/_drafts"):
        if os.path.isfile(config['site']['jekyll_root'] + "_posts/_drafts/" + f):
          posts.append(f)
      posts.sort(reverse=True)
      il = ItemsListWindow(posts)
      il.set_window_size({'left_type': 'relative', 'left_value': 2,
                           'right_type': 'relative', 'right_value': 50,
                           'bottom_type': 'relative', 'bottom_value': 2,
                           'top_type' : 'relative', 'top_value': 2,
                           'height': 10,
                           'width': 15})
      rebuild_file_list = False

    if (redraw):
      window_prep(stdscr, "utterson:draft posts", {'Q': 'Quit', 'E': 'Edit', 'P': 'Publish', 
                                                   'N': 'New', 'I': 'Info'})
      if (notice_txt is not None):
        notice_header(stdscr,notice_txt)
        notice_txt = None
      stdscr.refresh()
      il.build_item_list()
      il.refresh_window()
      

      redraw = False


    key = stdscr.getch()

    if (key == curses.KEY_DOWN):
      il.select_down()
    elif (key == curses.KEY_UP):
      il.select_up()
    elif (key == ord('e') or key == ord('E')):
      selected = il.get_selected()
      subprocess.call(['vim', config['site']['jekyll_root'] + "_posts/_drafts/" + selected])
      curses.curs_set(1)
      curses.curs_set(0)
      redraw = True
    elif (key == ord('p') or key == ord('P')):
      selected = il.get_selected()
      sure = yes_no_prompt(stdscr, 'Publish?: ' + selected + ' (y/n)')
      if (sure):
        shutil.move(config['site']['jekyll_root'] + "_posts/_drafts/" + selected,
                    config['site']['jekyll_root'] + "_posts/" + selected)
        rebuild_file_list = True
        redraw = True
        notice_txt = 'Published: ' + selected
      else:
        redraw = True
    elif (key == ord('n') or key == ord('N')):
      title = get_string_prompt(stdscr, 'New Post Name')
      if (os.path.isfile(config['site']['jekyll_root'] + "_posts/_templates/template.textile")):
        shutil.copy(config['site']['jekyll_root'] + "_posts/_templates/template.textile",
                    config['site']['jekyll_root'] + "_posts/_drafts/" + title)
      subprocess.call(['vim', config['site']['jekyll_root'] + "_posts/_drafts/" + title])
      curses.curs_set(1)
      curses.curs_set(0)
      redraw = True
      rebuild_file_list = True
    elif (key == ord('i') or key == ord('I')):
      selected = il.get_selected()
      post = JekyllPost(config['site']['jekyll_root'] + "_posts/_drafts/" + selected)
      notice_txt = post.meta_data["title"]
      redraw = True




def template_post_screen(stdscr):

  window_prep(stdscr, "utterson:templates", None)
  stdscr.refresh()

  posts = []
  for f in os.listdir(config['site']['jekyll_root'] + "_posts/_templates"):
    if os.path.isfile(config['site']['jekyll_root'] + "_posts/_templates/" + f):
      posts.append(f)
  posts.sort(reverse=True)
  il = ItemsListWindow(posts)
  il.set_window_size({'left_type': 'relative', 'left_value': 2,
                       'right_type': 'relative', 'right_value': 50,
                       'bottom_type': 'relative', 'bottom_value': 2,
                       'top_type' : 'relative', 'top_value': 2,
                       'height': 10,
                       'width': 15})
  il.build_item_list()
  il.refresh_window()
  

  key = 0
  while (key != ord('q')):

    key = stdscr.getch()

    if (key == curses.KEY_DOWN):
      il.select_down()
    elif (key == curses.KEY_UP):
      il.select_up()

def posts_main_screen(stdscr):
  """Displays and manages the posts main screen."""

  redraw = True
  key = 0

  # Run event loop on keys
  while key != ord('q'):

    if (redraw):
      # Write the left menu.
      window_prep(stdscr, "utterson: Posts", {'Q': 'Quit'})
      opts = collections.OrderedDict()
      opts['D'] = ['Drafts', 'Created/Edit/Delete drafts.']
      opts['P'] = ['Published Posts', 'Manage published posts']
      opts['T'] = ['Templates', 'Created/Edit/Delete templates']
      opts['Q'] = ['Quit', 'Return to home screen']

      build_full_screen_menu(stdscr, opts)
      #stdscr.addstr(2,2,'D - Drafts')
      #stdscr.addstr(3,2,'P - Published Posts')
      #stdscr.addstr(4,2,'T - Templates') 

    key = stdscr.getch()

    if (key == ord('d') or key == ord('D')):
      draft_post_screen(stdscr)
      redraw = True

      # Obtain all the posts and display.
        

    if (key == ord('p') or key == ord('P')):
      published_post_screen(stdscr)
      redraw = True

    if (key == ord('t') or key == ord('T')):
      template_post_screen(stdscr)
      redraw = True


def load_configuration(config_file_dir):
  stream = open(config_file_dir, 'r')
  global config
  config = yaml.load(stream)
  stream.close()

def yes_no_prompt(stdscr, question):
  lines_offset = (curses.LINES - 3) // 2
  cols_offset = (curses.COLS - len(question) - 2) // 2
  window = curses.newwin(3,len(question) + 2, lines_offset, cols_offset)
  window.border(0)
  window.addstr(1,1,question)
  window.refresh()

  while (True):
    key = stdscr.getch()

    if (key == ord('y') or key == ord('Y')):
      return True
    elif (key == ord('n') or key == ord('N')):
      return False

def get_string_prompt(stdscr, question):
  """

  Displays a text box in the center of screen. Allows users to enter a single
  string

  """
  # Prepare Question Backing Window
  question = question[:48].strip()
  question_offset = (50 - len(question))//2 + 1
  lines_offset = (curses.LINES - 3) // 2
  cols_offset = (curses.COLS - 50) // 2
  window = curses.newwin(3,52,lines_offset, cols_offset)
  window.border(0)
  window.addstr(0,question_offset,question)
  window.refresh()

  # Build textbox
  curses.curs_set(1)
  textbox_window = curses.newwin(1,50, lines_offset+1, cols_offset+1)
  textbox = curses.textpad.Textbox(textbox_window,insert_mode=True)
  
  # Wait for input and return.
  textbox.edit()
  curses.curs_set(0)
  return textbox.gather()

def parse_startup_arguments():
  """Builds and processes the startup arguments."""

  parser = argparse.ArgumentParser(description='utterson: A terrible Jekyll management system.')
  parser.add_argument('--version', action='version', version='%(prog)s ' + utterson_version)
  parser.add_argument('-config_file', default='config.yml')

  build_generate_group = parser.add_mutually_exclusive_group()
  build_generate_group.add_argument('-generate_config', action='store_true')
  build_generate_group.add_argument('-build_utterson')

  global startup_opts 
  startup_opts = vars(parser.parse_args())

def generate_jekyll_config(path, site_title):
  """Builds a jekyll site configuration file."""

  cf = open(path + "/_config.yml", 'w')
  cf.write('name: ' + site_title + '\n')
  cf.write('paginate: 7\n')
  cf.close()

def generate_utterson_config(path, site_title):
  """Builds an empty utterson configuration file at the location specified at run time."""

  cf = open(path + "/config.yml", 'w')
  cf.write('site:\n')
  cf.write('  url:\n')
  cf.write('  deployment_root: ' + path + '/jekyll_root/\n')
  cf.write('  site_title: ' + site_title + '\n')
  cf.close()

def build_utterson_base():
  """Builds an empty utterson site based on jekyll."""

  # Collect any information needed.
  site_title = input('Site title: ')

  # Create the directory structure.
  root = startup_opts["build_utterson"]
  os.makedirs(root + "/jekyll_root/_includes")
  os.makedirs(root + "/jekyll_root/_posts/_drafts")
  os.makedirs(root + "/jekyll_root/_posts/_templates")
  os.makedirs(root + "/jekyll_root/_posts/_deleted")
  os.makedirs(root + "/jekyll_root/css")
  os.makedirs(root + "/jekyll_root/_layouts")
  os.makedirs(root + "/jekyll_root/_site")
  os.makedirs(root + "/jekyll_root/photos")


  # Write default configuration file.
  generate_utterson_config(root, site_title)
  generate_jekyll_config(root + "/jekyll_root", site_title)

  print('-build_utterson has not been implemented.')
  exit(1)

def test_for_requirements():
  """Tests for utterson requirements."""

  # Test for jekyll
  if (is_executable_in_path('jekyll') is None):
    print ('Could not find Jekyll. Exiting....')
    exit(1)

def is_executable_in_path(executable_name):
  """Tests to see if the executable can be found in the current paths."""

  # Test the pwd case.
  path, name = os.path.split(executable_name)
  if (path):
    if (os.path.isfile(path) and os.access(path, os.X_OK)):
      return executable_name
  else:
    for path in os.environ["PATH"].split(os.pathsep):
      path = path.strip('"')
      executable_location = os.path.join(path, executable_name)
      if (os.path.isfile(executable_location) and os.access(executable_location, os.X_OK)):
        return executable_location

  return None


def main():
  
  test_for_requirements()

  parse_startup_arguments()

  # Build a configuration if requested.
  if (startup_opts["generate_config"]):
    generate_utterson_config(".", "Empty Config")
    exit(1)

  # Build an empty utterson config.
  if (startup_opts["build_utterson"]):
    build_utterson_base()

  # Load configuration file and globals.
  load_configuration(startup_opts['config_file'])

  wrapper(window_main)

def window_main(stdscr):
	
  # Reset to the default colors. Wrapper for some reason reverses.
  curses.use_default_colors()

  # Build Main Window
  #stdscr = curses.initscr()
  curses.noecho()
  curses.cbreak()
  curses.curs_set(0)
  stdscr.keypad(True)
  # Start home screen.
  home_screen(stdscr)
  

  # Exit
  stdscr.clear()
  stdscr.refresh()
  curses.endwin()	










class JekyllPost:
  """Basic class that represents a jekyll post."""

  def __init__(self, file_path):
    
    # Save the file path for future use.
    self.file_path = file_path
    self.meta_data = None
    self.meta_data_str = ''
    self.text = []

    # Read the file.
    temp_file = open(file_path, 'r')
    self.file = temp_file.readlines()
    temp_file.close()

    self._parse_jekyll_post()

  def _parse_jekyll_post(self):

    meta_start = False

    for line in self.file:
      # Meta data starts
      if line.strip() == '---':
        if (meta_start):
          meta_start = False
        else:
          meta_start = True

      if (meta_start):
        self.meta_data_str += line
      else:
        self.text.append(line.strip())

      self._parse_meta_data()

  def _parse_meta_data(self):
    self.meta_data = yaml.load(self.meta_data_str)






class ItemsListWindow:
  """

  Creates a navigatble items list.

  The ItemsListWindow class provides a basic ncurses based items list. and a
  dedicated ncurses window is created for it. The location and size of the 
  window may be specified. The instance also provides navigation/selection. 


  """

  def __init__(self, items):
    """Initialized the default values."""
    self.items = items
    self.selected_line = -1
    self.last_top_line = 0


  def set_window_size(self, options):
    """

    Sets the size of the ncurses window that the list will utilize.

    The window size may be supplied as both absolute and relative values.
    The options paramter should be a dictionary containg the following
    items. By default the height and width are only utilized when
    an absolute type is specified.

    {'left_type': 'relative', 'left_value': 2,
     'right_type': 'relative', 'right_value': 15,
     'bottom_type': 'relative', 'bottom_value': 10,
     'top_type': 'relative', 'top_value': 10,
     'height': 10,
     'width': 10}

    """

    self.window_width = 0
    self.window_cols_offset = 0
    self.window_height = 0
    self.window_rows_offset = 0

    # Determine width
    if (options['left_type'] == 'relative'):
      if (options['right_type'] == 'relative'):
        # Double relative width. Determine largest possible width.
        self.window_width = curses.COLS - options['left_value'] - options['right_value']
        self.window_cols_offset = options['left_value']
      else:
        # The right is absolute so we need to use the width value.
        if (curses.COLS < (options['left_value'] + options['width'])):
          # The width is too large so reduce.
          self.window_width = (curses.COLS - options['left_value'])
        else:
          self.window_width = options['width']

        self.window_cols_offset = options['left_value']
    elif(options['right_type'] == 'relative'):
      # Relative right with absolute left.
      if (curses.COLS < (options['right_value'] + options['width'])):
        self.window_width = (curses.COLS - options['right_value'])
      else:
        self.window_width = options['width']

      # The right is relative so calc it based on width.
      self.window_cols_offset = curses.COLS - options['width'] - options['right_value']
    else:
      # Must be all absolute so set to zero.
      self.window_width = options['width']
      self.window_cols_offset = 0

    # Determine height
    if (options['top_type'] == 'relative'):
      if (options['bottom_type'] == 'relative'):
        # Double relative height. Determine largest possible height.
        self.window_height = curses.LINES - options['top_value'] - options['bottom_value']
        self.window_rows_offset = options['top_value']
      else:
        # The bottom is absolute so we need to use the height value.
        if (curses.LINES < (options['top_value'] + options['height'])):
          # The height is too large so reduce.
          self.window_height = (curses.LINES - options['top_value'])
        else:
          self.window_height = options['height']

        self.window_rows_offset = options['top_value']
    elif(options['bottom_type'] == 'relative'):
      # Relative bottom with absolute top.
      if (curses.LINES < (options['bottom_value'] + options['height'])):
        self.window_height = (curses.LINES - options['bottom_value'])
      else:
        self.window_height = options['height']

      # The bottom is relative so calc it based on height.
      self.window_rows_offset = curses.LINES - options['height'] - options['bottom_value']
    else:
      # Must be all absolute so set to zero.
      self.window_height = options['height']
      self.window_rows_offset = 0


    # Build the window
    self.window = curses.newwin(self.window_height,self.window_width, self.window_rows_offset, self.window_cols_offset)
        
  def select_down(self):
    """Moves the selected row up."""


    if (self.selected_line < len(self.items) - 1):
      self.selected_line += 1

      # Determin what the top line should be.
      if ((self.selected_line - self.last_top_line) >= self.get_visible_lines()):
        self.last_top_line += 1

    self.build_item_list()
    self.refresh_window()

  def select_up(self):
    """Moves the selected row down."""
    if (self.selected_line > 0):
      self.selected_line -= 1

      # If the top line is out of range move the range.
      if (self.last_top_line > self.selected_line):
        self.last_top_line = self.selected_line

    self.build_item_list()
    self.refresh_window()

  def get_selected(self):
    return self.items[self.selected_line]

  def refresh_window(self):
    """Refreshes the window"""
    self.window.refresh()

  def get_visible_lines(self):
    """Determines the actual visible lines for redrawing."""

    if (len(self.items) > self.window_height):
      visible_lines = self.window_height
    else:
      visible_lines = len(self.items)

    return visible_lines

  def build_item_list(self):
    """Rebuilds the ncurses window."""
    #Calculate the maximum number of rows possible.

    visible_lines = self.get_visible_lines()
    
    line_number = 0
    for item_number in range(self.last_top_line, self.last_top_line + self.get_visible_lines()):
      if item_number == self.selected_line:
        self.window.addstr(line_number, 0, self.items[item_number], curses.A_STANDOUT)
      else:
        self.window.addstr(line_number, 0, self.items[item_number])
      line_number += 1


































# Start utterson
main()
